// å¤šè¯­è¨€æ–‡æœ¬
const i18nText = {
  'zh-CN': {
      score: 'åˆ†æ•°',
      time: 'å‰©ä½™æ—¶é—´',
      easy: 'å®¹æ˜“',
      medium: 'æ™®é€š',
      hard: 'å›°éš¾',
      gameName: 'æ•é±¼èƒ½æ‰‹',
      report: 'è®­ç»ƒæŠ¥å‘Š',
      back: 'è¿”å›',
      save: 'ä¿å­˜',
      print: 'æ‰“å°',
      exit: 'é€€å‡º',
      startTime: 'å¼€å§‹æ—¶é—´',
      heatmap: 'æ´»åŠ¨åŒºåŸŸçƒ­åº¦å›¾',
      gameRules: 'å‡†ç¡®ç‚¹å‡»å±å¹•ä¸Šé£å‡ºæµ·é¢çš„é±¼å³å¯å¾—åˆ†ï¼Œå¯ä»¥åŒæ—¶ç‚¹è§¦å¤šæ¡é±¼ï¼Œ<br>å¦‚æœç¢°åˆ°ç‚¸å¼¹åˆ™ä¼šè¢«æ‰£åˆ†ï¼Œæ³¨æ„èº²é¿ç‚¸å¼¹è·å¾—æ›´é«˜åˆ†æ•°ã€‚',
      personalInfo: 'ä¸ªäººä¿¡æ¯',
      trainingInfo: 'è®­ç»ƒä¿¡æ¯',
      imageAnalysis: 'å›¾åƒåˆ†æ',
      activityHeatmap: 'æ´»åŠ¨åŒºåŸŸçƒ­åŠ›å›¾',
      comments: 'æ„è§',
      signature: 'ç­¾å',
      name: 'å§“å',
      gender: 'æ€§åˆ«',
      age: 'å¹´é¾„',
      id: 'ç¼–å·',
      trainingName: 'è®­ç»ƒåç§°',
      trainingDuration: 'è®­ç»ƒæ—¶é•¿',
      scoreLabel: 'åˆ†æ•°',
      // å¯ç»§ç»­æ‰©å±•
  },
  'en-US': {
      score: 'Score',
      time: 'Time Left',
      easy: 'Easy',
      medium: 'Medium',
      hard: 'Hard',
      gameName: 'Fishing Expert',
      report: 'Training Report',
      back: 'Back',
      save: 'Save',
      print: 'Print',
      exit: 'Exit',
      startTime: 'Start Time',
      heatmap: 'Activity Area Heatmap',
      gameRules: 'Click accurately on fish jumping out of the sea to score points. You can click multiple fish at the same time.<br>If you hit a bomb, you will lose points. Avoid bombs to get higher scores.',
      personalInfo: 'Personal Information',
      trainingInfo: 'Training Information',
      imageAnalysis: 'Image Analysis',
      activityHeatmap: 'Activity Area Heatmap',
      comments: 'Comments',
      signature: 'Signature',
      name: 'Name',
      gender: 'Gender',
      age: 'Age',
      id: 'ID',
      trainingName: 'Training Name',
      trainingDuration: 'Training Duration',
      scoreLabel: 'Score',
  },
  'de-DE': {
      score: 'Punkte',
      time: 'Verbleibende Zeit',
      easy: 'Einfach',
      medium: 'Mittel',
      hard: 'Schwer',
      gameName: 'Angelmeister',
      report: 'Trainingsbericht',
      back: 'ZurÃ¼ck',
      save: 'Speichern',
      print: 'Drucken',
      exit: 'Beenden',
      startTime: 'Startzeit',
      heatmap: 'AktivitÃ¤tsbereich Heatmap',
      gameRules: 'Klicken Sie genau auf Fische, die aus dem Meer springen, um Punkte zu sammeln. Sie kÃ¶nnen mehrere Fische gleichzeitig anklicken.<br>Wenn Sie eine Bombe treffen, verlieren Sie Punkte. Vermeiden Sie Bomben, um hÃ¶here Punktzahlen zu erzielen.',
      personalInfo: 'PersÃ¶nliche Informationen',
      trainingInfo: 'Trainingsinformationen',
      imageAnalysis: 'Bildanalyse',
      activityHeatmap: 'AktivitÃ¤tsbereich Heatmap',
      comments: 'Kommentare',
      signature: 'Unterschrift',
      name: 'Name',
      gender: 'Geschlecht',
      age: 'Alter',
      id: 'ID',
      trainingName: 'Trainingsname',
      trainingDuration: 'Trainingsdauer',
      scoreLabel: 'Punkte',
  },
  'fr-FR': {
      score: 'Score',
      time: 'Temps restant',
      easy: 'Facile',
      medium: 'Moyen',
      hard: 'Difficile',
      gameName: 'Expert de la pÃªche',
      report: 'Rapport d\'entraÃ®nement',
      back: 'Retour',
      save: 'Enregistrer',
      print: 'Imprimer',
      exit: 'Quitter',
      startTime: 'Heure de dÃ©but',
      heatmap: 'Carte de chaleur de la zone d\'activitÃ©',
      gameRules: 'Cliquez avec prÃ©cision sur les poissons qui sautent hors de la mer pour marquer des points. Vous pouvez cliquer sur plusieurs poissons en mÃªme temps.<br>Si vous touchez une bombe, vous perdrez des points. Ã‰vitez les bombes pour obtenir des scores plus Ã©levÃ©s.',
      personalInfo: 'Informations personnelles',
      trainingInfo: 'Informations d\'entraÃ®nement',
      imageAnalysis: 'Analyse d\'image',
      activityHeatmap: 'Carte de chaleur de la zone d\'activitÃ©',
      comments: 'Commentaires',
      signature: 'Signature',
      name: 'Nom',
      gender: 'Genre',
      age: 'Ã‚ge',
      id: 'ID',
      trainingName: 'Nom de l\'entraÃ®nement',
      trainingDuration: 'DurÃ©e de l\'entraÃ®nement',
      scoreLabel: 'Score',
  },
  'es-ES': {
      score: 'PuntuaciÃ³n',
      time: 'Tiempo restante',
      easy: 'FÃ¡cil',
      medium: 'Medio',
      hard: 'DifÃ­cil',
      gameName: 'Experto en pesca',
      report: 'Informe de entrenamiento',
      back: 'Volver',
      save: 'Guardar',
      print: 'Imprimir',
      exit: 'Salir',
      startTime: 'Hora de inicio',
      heatmap: 'Mapa de calor de la zona de actividad',
      gameRules: 'Haz clic con precisiÃ³n en los peces que saltan fuera del mar para ganar puntos. Puedes hacer clic en mÃºltiples peces al mismo tiempo.<br>Si tocas una bomba, perderÃ¡s puntos. Evita las bombas para obtener puntuaciones mÃ¡s altas.',
      personalInfo: 'InformaciÃ³n personal',
      trainingInfo: 'InformaciÃ³n de entrenamiento',
      imageAnalysis: 'AnÃ¡lisis de imagen',
      activityHeatmap: 'Mapa de calor de la zona de actividad',
      comments: 'Comentarios',
      signature: 'Firma',
      name: 'Nombre',
      gender: 'GÃ©nero',
      age: 'Edad',
      id: 'ID',
      trainingName: 'Nombre del entrenamiento',
      trainingDuration: 'DuraciÃ³n del entrenamiento',
      scoreLabel: 'PuntuaciÃ³n',
  }
};
// ================= éŸ³æ•ˆç®¡ç†ç³»ç»Ÿ =================
class SoundManager {
    constructor() {
        this.sounds = {};
        this.isMuted = false;
        this.volume = 0.5; // ç›´æ¥ç”¨å¹³å‡éŸ³é‡
        this.init();
    }

    init() {
        // åˆå§‹åŒ–æ‰€æœ‰éŸ³æ•ˆ
        this.loadSounds();
        console.log('[éŸ³æ•ˆ] éŸ³æ•ˆç³»ç»Ÿåˆå§‹åŒ–å®Œæˆ');
    }

    loadSounds() {
        // æŒ‡å®šä¸åŒåœºæ™¯çš„æœ¬åœ°éŸ³æ•ˆ
        const soundUrls = {
            fishHit: 'assets/sound/1.mp3',
            bombHit: 'assets/sound/3.mp3',
            gameStart: 'assets/sound/1.mp3', // å¯è‡ªå®šä¹‰
            gameOver: 'assets/sound/2.mp3', // å¯è‡ªå®šä¹‰
            buttonClick: 'assets/sound/1.mp3', // å¯è‡ªå®šä¹‰
            pause: 'assets/sound/1.mp3', // å¯è‡ªå®šä¹‰
            resume: 'assets/sound/1.mp3', // å¯è‡ªå®šä¹‰
            scorePopup: 'assets/sound/1.mp3', // å¯è‡ªå®šä¹‰
            backgroundMusic: 'assets/sound/èƒŒæ™¯1.mp3'
        };

        // åˆ›å»ºéŸ³é¢‘å¯¹è±¡
        Object.keys(soundUrls).forEach(key => {
            this.sounds[key] = new Audio(soundUrls[key]);
            this.sounds[key].volume = this.volume;
            this.sounds[key].preload = 'auto';
            if (key === 'backgroundMusic') {
                this.sounds[key].loop = true;
            }
            // é”™è¯¯å¤„ç†
            this.sounds[key].onerror = () => {
                console.warn(`[éŸ³æ•ˆ] æ— æ³•åŠ è½½éŸ³æ•ˆ: ${key}`);
            };
            this.sounds[key].onload = () => {
                console.log(`[éŸ³æ•ˆ] éŸ³æ•ˆåŠ è½½æˆåŠŸ: ${key}`);
            };
        });
    }

    play(soundName) {
        if (this.isMuted || !this.sounds[soundName]) {
            return;
        }
        try {
            // èƒŒæ™¯éŸ³ä¹åªç”¨åŸå¯¹è±¡ï¼Œå…¶ä»–éŸ³æ•ˆå…‹éš†
            if (soundName === 'backgroundMusic') {
                this.sounds.backgroundMusic.volume = this.volume * 0.3;
                this.sounds.backgroundMusic.play().catch(error => {
                    console.warn('[éŸ³æ•ˆ] èƒŒæ™¯éŸ³ä¹æ’­æ”¾å¤±è´¥:', error);
                });
            } else {
                const sound = this.sounds[soundName].cloneNode();
                sound.volume = this.volume;
                sound.play().catch(error => {
                    console.warn(`[éŸ³æ•ˆ] æ’­æ”¾å¤±è´¥ ${soundName}:`, error);
                });
            }
        } catch (error) {
            console.warn(`[éŸ³æ•ˆ] æ’­æ”¾éŸ³æ•ˆå‡ºé”™ ${soundName}:`, error);
        }
    }

    playBackgroundMusic() {
        if (this.isMuted || !this.sounds.backgroundMusic) {
            return;
        }
        try {
            this.sounds.backgroundMusic.loop = true;
            this.sounds.backgroundMusic.volume = this.volume * 0.3;
            this.sounds.backgroundMusic.play().catch(error => {
                console.warn('[éŸ³æ•ˆ] èƒŒæ™¯éŸ³ä¹æ’­æ”¾å¤±è´¥:', error);
            });
        } catch (error) {
            console.warn('[éŸ³æ•ˆ] èƒŒæ™¯éŸ³ä¹æ’­æ”¾å‡ºé”™:', error);
        }
    }

    pauseBackgroundMusic() {
        if (this.sounds.backgroundMusic) {
            this.sounds.backgroundMusic.pause();
        }
    }

    resumeBackgroundMusic() {
        if (this.sounds.backgroundMusic && !this.isMuted) {
            this.sounds.backgroundMusic.play().catch(error => {
                console.warn('[éŸ³æ•ˆ] èƒŒæ™¯éŸ³ä¹æ¢å¤å¤±è´¥:', error);
            });
        }
    }

    stopBackgroundMusic() {
        if (this.sounds.backgroundMusic) {
            this.sounds.backgroundMusic.pause();
            this.sounds.backgroundMusic.currentTime = 0;
        }
    }

    setVolume(volume) {
        // å½»åº•ç¦ç”¨å¤–éƒ¨éŸ³é‡è®¾ç½®ï¼Œå§‹ç»ˆä¸º0.5
        this.volume = 0.5;
        Object.values(this.sounds).forEach(sound => {
            if (sound) {
                sound.volume = this.volume;
            }
        });
        console.log(`[éŸ³æ•ˆ] éŸ³é‡å›ºå®šä¸º: 0.5`);
    }

    toggleMute() {
        this.isMuted = !this.isMuted;
        if (this.isMuted) {
            this.stopBackgroundMusic();
        }
        console.log(`[éŸ³æ•ˆ] é™éŸ³çŠ¶æ€: ${this.isMuted}`);
        return this.isMuted;
    }

    isSoundMuted() {
        return this.isMuted;
    }

    getVolume() {
        return this.volume;
    }
}

// åˆå§‹åŒ–éŸ³æ•ˆç®¡ç†å™¨
const soundManager = new SoundManager();

// è¯­è¨€ç›‘å¬æ§åˆ¶å‡½æ•°ï¼ˆä¾›å¤–éƒ¨è°ƒç”¨ï¼‰
window.languageControl = {
    getCurrentLanguage: () => window.currentLang || 'zh-CN',
    getAvailableLanguages: () => Object.keys(i18nText),
    getSupportedLanguages: () => ['zh-CN', 'en-US', 'de-DE', 'fr-FR', 'es-ES'],
    changeLanguage: (newLang) => {
        if (typeof window.onLanguageChange === 'function') {
            window.onLanguageChange(newLang);
        } else {
            console.warn('[è¯­è¨€æ§åˆ¶] window.onLanguageChangeå‡½æ•°æœªå®šä¹‰');
        }
    },
    getLanguageInfo: () => {
        const currentLang = window.currentLang || 'zh-CN';
        return {
            currentLanguage: currentLang,
            availableLanguages: Object.keys(i18nText),
            supportedLanguages: ['zh-CN', 'en-US', 'de-DE', 'fr-FR', 'es-ES'],
            textKeys: Object.keys(i18nText[currentLang] || {}),
            isSupported: ['zh-CN', 'en-US', 'de-DE', 'fr-FR', 'es-ES'].includes(currentLang),
            fallbackUsed: !i18nText[currentLang] ? 'en-US' : 'none'
        };
    },
    logLanguageStatus: () => {
        const info = window.languageControl.getLanguageInfo();
        versionManager.log('info', 'è¯­è¨€çŠ¶æ€æŸ¥è¯¢', {
            ...info,
            timestamp: new Date().toISOString(),
            version: VERSION_CONFIG.currentVersion
        });
        console.log('[è¯­è¨€çŠ¶æ€]', info);
        return info;
    },
    testLanguageSwitch: (lang) => {
        console.log(`[è¯­è¨€æµ‹è¯•] å¼€å§‹æµ‹è¯•è¯­è¨€åˆ‡æ¢åˆ°: ${lang}`);
        versionManager.log('info', 'å¼€å§‹è¯­è¨€åˆ‡æ¢æµ‹è¯•', {
            targetLanguage: lang,
            timestamp: new Date().toISOString(),
            version: VERSION_CONFIG.currentVersion
        });
        
        if (typeof window.onLanguageChange === 'function') {
            window.onLanguageChange(lang);
            setTimeout(() => {
                const currentLang = window.currentLang;
                const pageTitle = document.title;
                const scoreInfo = document.getElementById('scoreInfo')?.textContent;
                const backBtn = document.getElementById('backBtn')?.textContent;
                
                versionManager.log('info', 'è¯­è¨€åˆ‡æ¢æµ‹è¯•å®Œæˆ', {
                    targetLanguage: lang,
                    actualLanguage: currentLang,
                    pageTitle: pageTitle,
                    scoreInfo: scoreInfo,
                    backBtn: backBtn,
                    testPassed: currentLang === lang,
                    timestamp: new Date().toISOString(),
                    version: VERSION_CONFIG.currentVersion
                });
                
                console.log(`[è¯­è¨€æµ‹è¯•] æµ‹è¯•å®Œæˆ - ç›®æ ‡: ${lang}, å®é™…: ${currentLang}, é¡µé¢æ ‡é¢˜: ${pageTitle}`);
            }, 100);
        } else {
            console.warn('[è¯­è¨€æµ‹è¯•] window.onLanguageChangeå‡½æ•°æœªå®šä¹‰');
        }
    }
};

// ================= éŸ³æ•ˆç®¡ç†ç³»ç»Ÿ END =================

// ç‰ˆæœ¬ä¿¡æ¯é…ç½®
const VERSION_CONFIG = {
    currentVersion: 'v1.2.0',
    buildDate: '2024-12-19',
    buildHash: '#a1b2c3d',
    minRequiredVersion: 'v1.0.0',
    updateCheckUrl: 'https://api.example.com/version-check', // å¯é€‰çš„è¿œç¨‹ç‰ˆæœ¬æ£€æŸ¥URL
    logLevel: 'info' // 'debug', 'info', 'warn', 'error'
};

// ç‰ˆæœ¬éªŒè¯å’Œæ—¥å¿—ç³»ç»Ÿ
class VersionManager {
    constructor() {
        this.logs = [];
        this.isLatestVersion = false;
        this.versionCheckComplete = false;
        this.init();
    }

    init() {
        this.updateVersionDisplay();
        this.log('info', 'ç‰ˆæœ¬ç®¡ç†ç³»ç»Ÿåˆå§‹åŒ–å®Œæˆ');
        this.checkVersion();
    }

    log(level, message, data = null) {
        const timestamp = new Date().toLocaleTimeString();
        const logEntry = {
            timestamp,
            level,
            message,
            data
        };
        
        this.logs.push(logEntry);
        this.updateLogDisplay();
        
        // æ§åˆ¶å°è¾“å‡º
        const consoleMethod = level === 'error' ? 'error' : 
                             level === 'warn' ? 'warn' : 
                             level === 'debug' ? 'debug' : 'log';
        console[consoleMethod](`[${timestamp}] [${level.toUpperCase()}] ${message}`, data || '');
    }

    updateVersionDisplay() {
        const t = i18nText[window.currentLang] || i18nText['en-US'];
        const currentVersionEl = document.getElementById('currentVersion');
        const buildDateEl = document.getElementById('buildDate');
        const buildHashEl = document.getElementById('buildHash');
        const versionStatusEl = document.getElementById('versionStatus');

        if (currentVersionEl) currentVersionEl.textContent = `${t.currentVersion || 'å½“å‰ç‰ˆæœ¬'}: ${VERSION_CONFIG.currentVersion}`;
        if (buildDateEl) buildDateEl.textContent = `${t.buildDate || 'æ„å»ºæ—¥æœŸ'}: ${VERSION_CONFIG.buildDate}`;
        if (buildHashEl) buildHashEl.textContent = `${t.buildHash || 'æ„å»ºå“ˆå¸Œ'}: ${VERSION_CONFIG.buildHash}`;

        // æ›´æ–°ç‰ˆæœ¬çŠ¶æ€
        if (versionStatusEl) {
            versionStatusEl.className = 'version-status version-checking';
            versionStatusEl.textContent = t.checking || 'æ£€æŸ¥ä¸­...';
        }
    }

    updateLogDisplay() {
        const logContent = document.getElementById('logContent');
        if (!logContent) return;

        // åªæ˜¾ç¤ºæœ€è¿‘çš„10æ¡æ—¥å¿—
        const recentLogs = this.logs.slice(-10);
        logContent.innerHTML = recentLogs.map(log => 
            `<div style="margin-bottom: 2px; font-size: 10px;">
                <span style="color: #888;">[${log.timestamp}]</span> 
                <span style="color: ${this.getLogColor(log.level)};">[${log.level.toUpperCase()}]</span> 
                ${log.message}
            </div>`
        ).join('');
    }

    getLogColor(level) {
        switch (level) {
            case 'error': return '#ff4444';
            case 'warn': return '#ffaa00';
            case 'info': return '#00ff00';
            case 'debug': return '#888888';
            default: return '#ffffff';
        }
    }

    async checkVersion() {
        this.log('info', 'å¼€å§‹ç‰ˆæœ¬æ£€æŸ¥');
        
        try {
            // æ¨¡æ‹Ÿç‰ˆæœ¬æ£€æŸ¥è¿‡ç¨‹
            await this.simulateVersionCheck();
            
            // å®é™…é¡¹ç›®ä¸­å¯ä»¥è°ƒç”¨è¿œç¨‹APIæ£€æŸ¥ç‰ˆæœ¬
            // const response = await fetch(VERSION_CONFIG.updateCheckUrl);
            // const latestVersion = await response.json();
            
        } catch (error) {
            this.log('error', 'ç‰ˆæœ¬æ£€æŸ¥å¤±è´¥', error.message);
            this.setVersionStatus('error', 'æ£€æŸ¥å¤±è´¥');
        }
    }

    async simulateVersionCheck() {
        // æ¨¡æ‹Ÿç½‘ç»œå»¶è¿Ÿ
        await new Promise(resolve => setTimeout(resolve, 2000));
        
        // æ¨¡æ‹Ÿç‰ˆæœ¬æ¯”è¾ƒé€»è¾‘
        const isLatest = Math.random() > 0.3; // 70%æ¦‚ç‡æ˜¯æœ€æ–°ç‰ˆæœ¬
        
        if (isLatest) {
            this.log('info', 'å½“å‰ç‰ˆæœ¬æ˜¯æœ€æ–°ç‰ˆæœ¬');
            this.setVersionStatus('latest', 'æœ€æ–°ç‰ˆæœ¬');
        } else {
            this.log('warn', 'å‘ç°æ–°ç‰ˆæœ¬å¯ç”¨');
            this.setVersionStatus('outdated', 'éœ€è¦æ›´æ–°');
        }
        
        this.versionCheckComplete = true;
        this.isLatestVersion = isLatest;
    }

    setVersionStatus(status, text) {
        const versionStatusEl = document.getElementById('versionStatus');
        if (!versionStatusEl) return;

        versionStatusEl.className = `version-status version-${status}`;
        versionStatusEl.textContent = text;
        
        this.log('info', `ç‰ˆæœ¬çŠ¶æ€æ›´æ–°: ${text}`);
    }

    showLogs() {
        const logElement = document.getElementById('versionLog');
        if (logElement) {
            logElement.style.display = logElement.style.display === 'none' ? 'block' : 'none';
        }
    }

    getVersionInfo() {
        return {
            currentVersion: VERSION_CONFIG.currentVersion,
            buildDate: VERSION_CONFIG.buildDate,
            buildHash: VERSION_CONFIG.buildHash,
            isLatestVersion: this.isLatestVersion,
            versionCheckComplete: this.versionCheckComplete,
            logs: this.logs
        };
    }

    exportLogs() {
        const logData = {
            version: VERSION_CONFIG.currentVersion,
            timestamp: new Date().toISOString(),
            logs: this.logs
        };
        
        const blob = new Blob([JSON.stringify(logData, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `version-log-${new Date().toISOString().split('T')[0]}.json`;
        a.click();
        URL.revokeObjectURL(url);
        
        this.log('info', 'ç‰ˆæœ¬æ—¥å¿—å·²å¯¼å‡º');
    }
}

// åˆå§‹åŒ–ç‰ˆæœ¬ç®¡ç†å™¨
const versionManager = new VersionManager();

// æ·»åŠ é”®ç›˜å¿«æ·é”®æ˜¾ç¤º/éšè—æ—¥å¿—
document.addEventListener('keydown', (e) => {
    if (e.ctrlKey && e.key === 'l') {
        e.preventDefault();
        versionManager.showLogs();
    }
    if (e.ctrlKey && e.key === 'e') {
        e.preventDefault();
        versionManager.exportLogs();
    }
    // éŸ³æ•ˆæ§åˆ¶å¿«æ·é”®
    if (e.key === 'm' || e.key === 'M') {
        e.preventDefault();
        const isMuted = soundManager.toggleMute();
        const soundToggle = document.getElementById('soundToggle');
        if (soundToggle) {
            soundToggle.textContent = isMuted ? 'ğŸ”‡' : 'ğŸ”Š';
        }
    }
    if (e.key === 'ArrowUp' && e.ctrlKey) {
        e.preventDefault();
        const currentVolume = soundManager.getVolume();
        const newVolume = Math.min(1, currentVolume + 0.1);
        soundManager.setVolume(newVolume);
        const volumeSlider = document.getElementById('volumeSlider');
        if (volumeSlider) {
            volumeSlider.value = newVolume * 100;
        }
    }
    if (e.key === 'ArrowDown' && e.ctrlKey) {
        e.preventDefault();
        const currentVolume = soundManager.getVolume();
        const newVolume = Math.max(0, currentVolume - 0.1);
        soundManager.setVolume(newVolume);
        const volumeSlider = document.getElementById('volumeSlider');
        if (volumeSlider) {
            volumeSlider.value = newVolume * 100;
        }
    }
    if (e.key === 't' && e.ctrlKey) {
        e.preventDefault();
        soundManager.play('scorePopup');
    }
});

// å…¨å±€å˜é‡å£°æ˜
let selectedTrainingTime = 10 * 60000; // é»˜è®¤10åˆ†é’Ÿ
let currentDifficulty = 'normal'; // é»˜è®¤éš¾åº¦
const difficulties = {
    easy: 'easy',
    medium: 'normal',
    hard: 'hard'
};
      

      

      

      




const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const result = document.getElementById('result');
const backBtn = document.getElementById('backBtn');
const scoreText = document.getElementById('scoreText');
const timerDisplay = document.getElementById('timerDisplay'); // æ·»åŠ è®¡æ—¶å™¨æ˜¾ç¤ºå…ƒç´ çš„å¼•ç”¨

// æ¸¸æˆå¸¸é‡
const GRAVITY = 0.15; // å‡å°é‡åŠ›åŠ é€Ÿåº¦ï¼Œè®©è¿åŠ¨æ›´ç¼“æ…¢

// åŠ è½½é±¼å›¾ç‰‡
const fishImages = [];
for (let i = 1; i <= 7; i++) { // ä¿®æ”¹ä¸º7ç§é±¼
  const img = new Image();
  img.src = `assets/fish${i}.png`;
  img.onerror = () => console.warn(`é±¼å›¾ç‰‡${i}åŠ è½½å¤±è´¥: assets/fish${i}.png`);
  fishImages.push(img);
}

// åŠ è½½ç‚¸å¼¹å›¾ç‰‡
const bombImg = new Image();
bombImg.src = 'assets/bomb.png';
bombImg.onerror = () => console.warn('ç‚¸å¼¹å›¾ç‰‡åŠ è½½å¤±è´¥: assets/bomb.png');

// åŠ è½½äº‘å›¾ç‰‡
const cloud1Img = new Image();
cloud1Img.src = 'assets/cloud1.png';
cloud1Img.onerror = () => console.warn('äº‘å›¾ç‰‡åŠ è½½å¤±è´¥: assets/cloud1.png');

// åŠ è½½æ°”çƒå›¾ç‰‡
const balloon1Img = new Image();
balloon1Img.src = 'assets/ballon1.png';
balloon1Img.onload = () => console.log('æ°”çƒ1å›¾ç‰‡åŠ è½½æˆåŠŸ');
balloon1Img.onerror = () => console.log('æ°”çƒ1å›¾ç‰‡åŠ è½½å¤±è´¥');

// æ¸¸æˆçŠ¶æ€å˜é‡
let gameState = 'config'; // 'config', 'playing', 'paused', 'gameOver'
let score = 0;
let lives = 3;
let gameMode = 'easy'; // 'easy', 'normal', 'hard'
let bombCount = 1; // é»˜è®¤ç‚¸å¼¹æ•°é‡
let balloonTimer = 0;
let lastTime = 0;
let gameStartTime = 0;
let gameTime = 0;
let isPaused = false;
let fishes = [];
let bombs = [];
let fishCounts = Array(7).fill(0); // 7ç§é±¼çš„æ•°é‡ç»Ÿè®¡
let bombCounts = 0; // ç‚¸å¼¹æ•°é‡ç»Ÿè®¡
let timeLeft = gameTime;
let difficulty = 'normal';
let isSpawning = false;
let roundInterval = 3000;
let scorePopups = [];
let timerTimeout = null; // ç”¨äºå­˜å‚¨è®¡æ—¶å™¨
let startTime = 0; // æ·»åŠ å¼€å§‹æ—¶é—´è®°å½•
let clickPoints = [];

// äº‘æœµå¯¹è±¡
const clouds = [
  {
    x: Math.random() * canvas.width,
    y: 50 + Math.random() * 50,
    speed: 0.5 + Math.random() * 0.5,
    img: cloud1Img,
    width: 300,
    height: 150
  },
  {
    x: Math.random() * canvas.width,
    y: 120 + Math.random() * 50,
    speed: -(0.3 + Math.random() * 0.3),
    img: cloud1Img,
    width: 300,
    height: 150
  }
];

// æ°”çƒå¯¹è±¡æ•°ç»„
const balloons = [];



// é±¼çš„åŸºç¡€é€Ÿåº¦å‡½æ•°
function getFishBaseSpeed() {
  if (difficulty === 'easy') return 12; // å¢åŠ åŸºç¡€é€Ÿåº¦ï¼Œè®©é±¼è·³å¾—æ›´é«˜
  if (difficulty === 'normal') return 10;
  return 8;
}

// ç‚¸å¼¹çš„åŸºç¡€é€Ÿåº¦å‡½æ•°
function getBombBaseSpeed() {
  return 3.0; // è¿›ä¸€æ­¥å¢åŠ ç‚¸å¼¹åŸºç¡€é€Ÿåº¦ï¼Œè®©ç‚¸å¼¹è·³å¾—æ›´é«˜
}

function showConfigModal() {
    const configModal = document.getElementById('configModal');
    if (configModal) {
        configModal.style.display = 'flex';
        gameState = 'config';
    }
}

function hideConfigModal() {
    const configModal = document.getElementById('configModal');
    if (configModal) {
        configModal.style.display = 'none';
    }
}

function getConfigValues() {
    const difficulty = document.getElementById('difficultySelect').value;
    const trainingTime = parseInt(document.getElementById('trainingTimeInput').value) * 60 * 1000; // è½¬æ¢ä¸ºæ¯«ç§’
    
    return {
        difficulty,
        trainingTime
    };
}

function startGameFromConfig() {
    const config = getConfigValues();
    
    // è®¾ç½®æ¸¸æˆå‚æ•°
    setGameMode(config.difficulty);
    selectedTrainingTime = config.trainingTime;
    currentDifficulty = config.difficulty; // ç¡®ä¿è®¾ç½®å½“å‰éš¾åº¦
    
    // éšè—é…ç½®é¡µé¢
    hideConfigModal();
    
    // å¼€å§‹æ¸¸æˆ
    startGame();
    
    // è®°å½•é…ç½®ä¿¡æ¯
    versionManager.log('info', 'ä»é…ç½®é¡µé¢å¼€å§‹æ¸¸æˆ', {
        difficulty: config.difficulty,
        trainingTime: config.trainingTime
    });
}

function showResult() {
  if (result) result.style.display = 'flex';
}

let spawnTimeouts = [];

function clearSpawnTimeouts() {
  spawnTimeouts.forEach(id => clearTimeout(id));
  spawnTimeouts = [];
}

function spawnRound() {
  if (isSpawning) return;
  isSpawning = true;
  
  const fishCount = 10;
  const currentBombCount = bombCount;
  let spawnedCount = 0;
  let bombGenerated = 0;
  let fishGenerated = 0;
  const total = fishCount + currentBombCount;
  for (let i = 0; i < total; i++) {
    let isBomb = false;
    if (bombGenerated < currentBombCount && (fishGenerated % 2 === 0) && fishGenerated !== 0) {
      isBomb = true;
      bombGenerated++;
    } else if (fishGenerated < fishCount) {
      isBomb = false;
      fishGenerated++;
    } else if (bombGenerated < currentBombCount) {
      isBomb = true;
      bombGenerated++;
    }
    const randomFishImg = isBomb ? bombImg : fishImages[Math.floor(Math.random() * fishImages.length)];
    const baseSpeed = isBomb ? getBombBaseSpeed() : getFishBaseSpeed();
    const initialVy = isBomb ? 
      -(baseSpeed * 3.3 + Math.random() * (baseSpeed * 0.9)) :
      -(baseSpeed + Math.random() * (baseSpeed * 0.2));
    const initialVx = isBomb ? 
      (0.4 + Math.random() * 1.0) :
      (0.2 + Math.random() * 0.4);
    let x;
    let y = canvas.height - 150;
    let width, height;
    if (isBomb) {
      width = 120;
      height = 120;
      const centerStart = canvas.width * 0.3;
      const centerWidth = canvas.width * 0.4;
      const sectionWidth = centerWidth / currentBombCount;
      const section = bombGenerated - 1;
      x = centerStart + section * sectionWidth + Math.random() * (sectionWidth * 0.8);
    } else {
      const fishIndex = fishImages.indexOf(randomFishImg);
      width = fishIndex === 3 ? 180 : 200;
      height = fishIndex === 3 ? 150 : 133;
      const fishIdx = fishGenerated - 1;
      if (fishIdx < 6) {
        const centerStart = canvas.width * 0.3;
        const centerWidth = canvas.width * 0.4;
        const sectionCount = 3;
        const sectionWidth = centerWidth / sectionCount;
        const section = Math.floor(fishIdx / 2);
        x = centerStart + section * sectionWidth + Math.random() * (sectionWidth * 0.8);
      } else if (fishIdx < 8) {
        x = 100 + Math.random() * (canvas.width * 0.2);
      } else {
        x = canvas.width * 0.8 + Math.random() * (canvas.width * 0.2 - 100);
      }
    }
    x = Math.max(100, Math.min(canvas.width - 300, x));

    // é¿å…é±¼å®Œå…¨é‡åˆï¼šæœ€å¤šå°è¯•10æ¬¡
    let tryCount = 0;
    function isOverlap(a, b) {
      return !(
        a.x + a.width < b.x ||
        b.x + b.width < a.x ||
        a.y + a.height < b.y ||
        b.y + b.height < a.y
      );
    }
    while (!isBomb && tryCount < 10) {
      let overlap = false;
      for (let f of fishes) {
        if (isOverlap({x, y, width, height}, f)) {
          overlap = true;
          break;
        }
      }
      if (!overlap) break;
      // é‡æ–°éšæœºx
      if (fishGenerated - 1 < 6) {
        const centerStart = canvas.width * 0.3;
        const centerWidth = canvas.width * 0.4;
        const sectionCount = 3;
        const sectionWidth = centerWidth / sectionCount;
        const section = Math.floor((fishGenerated - 1) / 2);
        x = centerStart + section * sectionWidth + Math.random() * (sectionWidth * 0.8);
      } else if (fishGenerated - 1 < 8) {
        x = 100 + Math.random() * (canvas.width * 0.2);
      } else {
        x = canvas.width * 0.8 + Math.random() * (canvas.width * 0.2 - 100);
      }
      x = Math.max(100, Math.min(canvas.width - 300, x));
      tryCount++;
    }

    const baseDelay = isBomb ? 450 : 300;
    const intervalDelay = isBomb ? 120 : 150;
    const randomDelay = Math.floor(Math.random() * 100);
    const delay = baseDelay + (i * intervalDelay) + randomDelay;
    const timeoutId = setTimeout(() => {
      if (isBomb) {
        bombs.push({
          x: x,
          y: y,
          vy: initialVy,
          vx: initialVx,
          clicked: false,
          img: bombImg,
          width: width,
          height: height,
          hasPausedAtTop: false,
          lastVy: initialVy,
          pauseTimer: 0,
          isPaused: false,
          originalVx: initialVx,
          vx: 0
        });
      } else {
        fishes.push({
          x: x,
          y: y,
          vy: initialVy,
          vx: initialVx,
          clicked: false,
          img: randomFishImg,
          width: width,
          height: height,
          rotation: -30,
          rotationSpeed: 1.2,
          maxRotation: 30,
          startRotation: false,
          pauseTimer: 0,
          isPaused: false
        });
      }
      spawnedCount++;
      if (spawnedCount === total) {
        const roundTimeoutId = setTimeout(() => {
          isSpawning = false;
          if (gameState === 'playing') {
            spawnRound();
          }
        }, roundInterval + 2000);
        spawnTimeouts.push(roundTimeoutId);
      }
    }, delay);
    spawnTimeouts.push(timeoutId);
  }
}

function getSpeed() {
  // è¿”å›åŸºç¡€å‘ä¸Šé€Ÿåº¦
  if (difficulty === 'easy') return 18; // è°ƒæ•´ä¸º18ï¼Œä½¿é±¼è·³å¾—æ›´é«˜
  if (difficulty === 'normal') return 14;
  return 10; // è°ƒæ•´ä¸º10ï¼Œä½¿é±¼è·³å¾—æ›´ä½
}
function getSpawnRate() {
  if (difficulty === 'easy') return [0.13, 0.02];
  if (difficulty === 'normal') return [0.10, 0.03];
  return [0.08, 0.05]; // ä¿æŒ0.05ï¼Œå¢åŠ ç‚¸å¼¹å‡ºç°æ¦‚ç‡
}

function getMaxBombsOnScreen() {
  if (difficulty === 'easy') return 1;
  if (difficulty === 'normal') return 2;
  return 3;
}




function draw() {
  const t = i18nText[window.currentLang] || i18nText['en-US'];
  // æ¸…ç©ºç”»å¸ƒ
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  // ä½¿ç”¨å¤©è“è‰²èƒŒæ™¯
  ctx.fillStyle = '#87CEEB';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  // ç»˜åˆ¶æ°”çƒï¼ˆåœ¨èƒŒæ™¯ä¹‹åï¼‰
  balloons.forEach(balloon => {
    try {
      if (balloon.img && balloon.img.complete && balloon.img.naturalWidth > 0) {
        ctx.drawImage(
          balloon.img,
          balloon.x,
          balloon.y,
          balloon.width,
          balloon.height
        );
      } else {
        // å›¾ç‰‡åŠ è½½å¤±è´¥æ—¶ç”»ä¸ªå ä½è‰²å—
        ctx.fillStyle = 'gray';
        ctx.fillRect(balloon.x, balloon.y, balloon.width, balloon.height);
      }
    } catch (error) {
      // å¦‚æœç»˜åˆ¶å›¾ç‰‡å¤±è´¥ï¼Œä½¿ç”¨å¤‡ç”¨çŸ©å½¢
      ctx.fillStyle = 'gray';
      ctx.fillRect(balloon.x, balloon.y, balloon.width, balloon.height);
    }
  });
  
  // ç»˜åˆ¶äº‘æœµ
  clouds.forEach(cloud => {
    try {
      if (cloud.img && cloud.img.complete && cloud.img.naturalWidth > 0) {
        ctx.drawImage(cloud.img, cloud.x, cloud.y, cloud.width, cloud.height);
      } else {
        // å›¾ç‰‡åŠ è½½å¤±è´¥æ—¶ç”»ä¸ªå ä½è‰²å—
        ctx.fillStyle = 'white';
        ctx.fillRect(cloud.x, cloud.y, cloud.width, cloud.height);
      }
    } catch (error) {
      // å¦‚æœç»˜åˆ¶å›¾ç‰‡å¤±è´¥ï¼Œä½¿ç”¨å¤‡ç”¨çŸ©å½¢
      ctx.fillStyle = 'white';
      ctx.fillRect(cloud.x, cloud.y, cloud.width, cloud.height);
    }
  });

  // å…ˆç»˜åˆ¶æœ€åº•å±‚æ³¢æµªï¼ˆæœ€æ·±ï¼‰
  ctx.fillStyle = '#006994'; // æ·±è“è‰²
  ctx.beginPath();
  ctx.moveTo(0, canvas.height - 330 - 15 + 50);
  for (let i = 0; i <= canvas.width; i += 20) {
    const y = canvas.height - 330 - 15 + 50 + Math.sin(i * 0.035) * 25;
    ctx.lineTo(i, y);
  }
  ctx.lineTo(canvas.width, canvas.height - 15 + 50);
  ctx.lineTo(0, canvas.height - 15 + 50);
  ctx.closePath();
  ctx.fill();

  // ç¬¬äºŒå±‚ï¼ˆä¸­ç­‰æ·±åº¦ï¼‰
  ctx.fillStyle = '#0099CC'; // ä¸­è“è‰²
  ctx.beginPath();
  ctx.moveTo(0, canvas.height - 260 - 15 + 50);
  for (let i = 0; i <= canvas.width; i += 20) {
    const y = canvas.height - 260 - 15 + 50 + Math.sin(i * 0.035) * 25;
    ctx.lineTo(i, y);
  }
  ctx.lineTo(canvas.width, canvas.height - 15 + 50);
  ctx.lineTo(0, canvas.height - 15 + 50);
  ctx.closePath();
  ctx.fill();

  // ç¬¬ä¸‰å±‚ï¼ˆè¾ƒæµ…ï¼‰
  ctx.fillStyle = '#00BFFF'; // æµ…è“è‰²
  ctx.beginPath();
  ctx.moveTo(0, canvas.height - 190 - 15 + 50);
  for (let i = 0; i <= canvas.width; i += 20) {
    const y = canvas.height - 190 - 15 + 50 + Math.sin(i * 0.035) * 25;
    ctx.lineTo(i, y);
  }
  ctx.lineTo(canvas.width, canvas.height - 15 + 50);
  ctx.lineTo(0, canvas.height - 15 + 50);
  ctx.closePath();
  ctx.fill();

  // ç»˜åˆ¶é±¼
  fishes.forEach(f => {
    try {
      if (f.img && f.img.complete && f.img.naturalWidth > 0) {
        ctx.save();
        ctx.translate(f.x + f.width/2, f.y + f.height/2);
        ctx.rotate(f.rotation * Math.PI / 180);
        ctx.drawImage(
          f.img,
          -f.width/2,
          -f.height/2,
          f.width,
          f.height
        );
        ctx.restore();
      } else {
        ctx.fillStyle = 'gold';
        ctx.fillRect(f.x, f.y, f.width, f.height);
      }
    } catch (error) {
      // å¦‚æœç»˜åˆ¶å›¾ç‰‡å¤±è´¥ï¼Œä½¿ç”¨å¤‡ç”¨çŸ©å½¢
      ctx.fillStyle = 'gold';
      ctx.fillRect(f.x, f.y, f.width, f.height);
    }
  });

  // ç”»ç‚¸å¼¹
  bombs.forEach(b => {
    try {
      if (b.img && b.img.complete && b.img.naturalWidth > 0) {
        ctx.drawImage(b.img, b.x, b.y, b.width, b.height);
      } else {
        ctx.fillStyle = 'black';
        ctx.beginPath();
        ctx.arc(b.x + b.width / 2, b.y + b.height / 2, b.width / 2, 0, 2 * Math.PI);
        ctx.fill();
      }
    } catch (error) {
      // å¦‚æœç»˜åˆ¶å›¾ç‰‡å¤±è´¥ï¼Œä½¿ç”¨å¤‡ç”¨åœ†å½¢
      ctx.fillStyle = 'black';
      ctx.beginPath();
      ctx.arc(b.x + b.width / 2, b.y + b.height / 2, b.width / 2, 0, 2 * Math.PI);
      ctx.fill();
    }
  });

  // æœ€åç»˜åˆ¶ç¬¬å››å±‚æ³¢æµªï¼ˆæœ€æµ…ï¼‰
  ctx.fillStyle = '#87CEFA';
  ctx.beginPath();
  ctx.moveTo(0, canvas.height - 120 - 15 + 50);
  for (let i = 0; i <= canvas.width; i += 20) {
    const y = canvas.height - 120 - 15 + 50 + Math.sin(i * 0.035) * 25;
    ctx.lineTo(i, y);
  }
  ctx.lineTo(canvas.width, canvas.height - 15 + 50);
  ctx.lineTo(0, canvas.height - 15 + 50);
  ctx.closePath();
  ctx.fill();

  // ç»˜åˆ¶åˆ†æ•°æç¤º
  scorePopups.forEach(popup => {
    ctx.save();
    ctx.globalAlpha = popup.alpha;
    ctx.fillStyle = popup.color || 'white'; // ä½¿ç”¨popup.coloræˆ–é»˜è®¤ç™½è‰²
    ctx.font = '24px Arial';
    ctx.textAlign = 'center';
    ctx.fillText(popup.text, popup.x, popup.y);
    ctx.restore();
    
    // æ’­æ”¾åˆ†æ•°å¼¹å‡ºéŸ³æ•ˆï¼ˆåªåœ¨ç¬¬ä¸€æ¬¡æ˜¾ç¤ºæ—¶æ’­æ”¾ï¼‰
    if (popup.alpha === 1 && !popup.soundPlayed) {
      soundManager.play('scorePopup');
      popup.soundPlayed = true;
    }
  });

  // ç»˜åˆ¶åˆ†æ•°å’Œæ—¶é—´
  ctx.fillStyle = 'black';
  ctx.font = '48px sans-serif';
  ctx.textAlign = 'left';
   
  // åœ¨å³ä¸Šè§’ç»˜åˆ¶ç‚¸å¼¹æ•è·æ•°é‡
  ctx.font = '24px sans-serif';
  ctx.textAlign = 'right';
  const startX = canvas.width - 20;
  const bombY = 60;
  
  try {
    if (bombImg && bombImg.complete && bombImg.naturalWidth > 0) {
      ctx.drawImage(bombImg, startX - 150, bombY - 20, 40, 40);
    }
  } catch (error) {
    // å¦‚æœç»˜åˆ¶å›¾ç‰‡å¤±è´¥ï¼Œä¸ç»˜åˆ¶ä»»ä½•ä¸œè¥¿
  }
  ctx.fillText(`x${bombCounts}`, startX, bombY);
  
  // åœ¨å³ä¸Šè§’ç»˜åˆ¶æ¯ç§é±¼çš„æ•è·æ•°é‡
  ctx.font = '24px sans-serif';
  ctx.textAlign = 'right';
  const startY = 100;
  const lineHeight = 30;
  
  fishCounts.forEach((count, index) => {
    const y = startY + index * lineHeight;
    try {
      if (fishImages[index] && fishImages[index].complete && fishImages[index].naturalWidth > 0) {
        ctx.drawImage(fishImages[index], startX - 150, y - 20, 40, 27);
      }
    } catch (error) {
      // å¦‚æœç»˜åˆ¶å›¾ç‰‡å¤±è´¥ï¼Œä¸ç»˜åˆ¶ä»»ä½•ä¸œè¥¿
    }
    ctx.fillText(`x${count}`, startX, y);
  });
}
function update() {
  // åˆ†æ•°å¼¹çª—ç­‰åŠ¨ç”»åœ¨æš‚åœæ—¶ä¸æ›´æ–°
  if (isPaused) return;
  fishes.forEach(f => {
    // æ£€æŸ¥æ˜¯å¦è¾¾åˆ°æœ€é«˜ç‚¹ï¼ˆvyä»è´Ÿå˜ä¸ºæ­£çš„æ—¶åˆ»ï¼‰
    if (!f.startRotation && f.vy > 0) {
      f.startRotation = true;
      f.isPaused = true; // å¼€å§‹æš‚åœ
      f.pauseTimer = 0; // é‡ç½®æš‚åœè®¡æ—¶å™¨
    }
    
    // å¤„ç†æš‚åœé€»è¾‘
    if (f.isPaused) {
      f.pauseTimer += 16; // å‡è®¾60fpsï¼Œæ¯å¸§çº¦16ms
      if (f.pauseTimer < 100) { // 0.1ç§’çš„è½¬åŠ¨è¿‡ç¨‹
        // ä½¿ç”¨ç¼“åŠ¨å‡½æ•°è®©æ—‹è½¬æ›´è‡ªç„¶
        const progress = f.pauseTimer / 100; // æ—‹è½¬è¿›åº¦(0-1)
        // ä½¿ç”¨æ›´å¹³ç¼“çš„ç¼“åŠ¨å‡½æ•°ï¼Œå¢åŠ æŒ‡æ•°è®©åŠ¨ä½œæ›´æ…¢
        const easedProgress = (1 - Math.cos(progress * Math.PI)) / 2.5; // é™¤ä»¥2.5è®©æ—‹è½¬æ›´æ…¢
        f.rotation = -30 + easedProgress * 60; // ä»-30åº¦åˆ°30åº¦
        
        // åœ¨æ—‹è½¬è¿‡ç¨‹ä¸­è‡ªç„¶ä¸‹è½
        f.vy += GRAVITY * 0.8; // ä½¿ç”¨80%çš„é‡åŠ›
        f.y += f.vy;
        f.x += f.vx * 0.8;
        return; // è·³è¿‡æ­£å¸¸çš„ä½ç½®æ›´æ–°
      }
      // æš‚åœç»“æŸåï¼Œrotationä¿æŒ30åº¦ä¸å˜ï¼Œæ¢å¤æ­£å¸¸ä¸‹è½é€Ÿåº¦
      f.rotation = f.maxRotation;
      f.isPaused = false;
    }
    
    // æ­£å¸¸è¿åŠ¨æ›´æ–°ï¼ˆéæš‚åœçŠ¶æ€ï¼‰
    f.vy += GRAVITY;
    f.y += f.vy;
    f.x += f.vx;
  });
  bombs.forEach(b => {
    updateBomb(b);
  });

  // æ›´æ–°äº‘æœµä½ç½®ï¼ˆåªåœ¨éæš‚åœçŠ¶æ€ï¼‰
  if (!isPaused) {
    clouds.forEach(cloud => {
      cloud.x += cloud.speed;
      // å½“äº‘æœµç§»å‡ºå±å¹•æ—¶ï¼Œä»å¦ä¸€ä¾§é‡æ–°è¿›å…¥
      if (cloud.speed > 0 && cloud.x > canvas.width) {
        cloud.x = -cloud.width;
      } else if (cloud.speed < 0 && cloud.x < -cloud.width) {
        cloud.x = canvas.width;
      }
    });
  }

  // æ›´æ–°åˆ†æ•°æç¤ºï¼ˆæš‚åœæ—¶ä¸æ›´æ–°ï¼‰
  scorePopups.forEach(popup => {
    popup.y -= 2;
    popup.alpha -= 0.02;
  });
  // ç§»é™¤å·²æ·¡å‡ºçš„åˆ†æ•°æç¤º
  scorePopups = scorePopups.filter(popup => popup.alpha > 0);

  // ç§»é™¤å·²ç‚¹å‡»æˆ–å®Œå…¨é£å‡ºå±å¹•çš„é±¼/ç‚¸å¼¹
  fishes = fishes.filter(f => 
    f.y < canvas.height + f.height && 
    f.y > -f.height * 2 && 
    f.x < canvas.width + f.width &&
    f.x > -f.width &&
    !f.clicked
  );
  bombs = bombs.filter(b => 
    b.y < canvas.height + b.height && 
    b.y > -b.height * 2 && 
    b.x < canvas.width + b.width &&
    b.x > -b.width &&
    !b.clicked
  );

  // æ›´æ–°æ°”çƒä½ç½®ï¼ˆåªåœ¨éæš‚åœçŠ¶æ€ï¼‰
  if (!isPaused) {
    for (let i = balloons.length - 1; i >= 0; i--) {
      updateBalloon(balloons[i]);
    }
  }
}
function gameLoop() {
  if (gameState === 'gameOver') {
    if (!gameOverBalloonEndTime) {
      gameOverBalloonEndTime = Date.now() + 2000;
    }
    // æ¸¸æˆç»“æŸæ—¶æ°”çƒç»§ç»­è¿åŠ¨ï¼ˆä¸å—æš‚åœå½±å“ï¼‰
    for (let i = balloons.length - 1; i >= 0; i--) {
      updateBalloon(balloons[i]);
    }
    draw();
    if (Date.now() < gameOverBalloonEndTime || balloons.length > 0) {
      gameOverBalloonTimer = requestAnimationFrame(gameLoop);
    } else {
      gameOverBalloonEndTime = 0;
      // å½»åº•åœä¸‹
    }
    return;
  }
  if (gameState !== 'playing' || isPaused) return;
  update();
  draw();
  if (balloons.length === 0) {
    spawnBalloon();
  }
  // æ–°å¢ï¼šè‡ªåŠ¨è¡¥å……ä¸€è½®
  if (!isSpawning && fishes.length === 0 && bombs.length === 0) {
    spawnRound();
  }
  requestAnimationFrame(gameLoop);
}
function startGame() {
  // åœæ­¢æ—§çš„åŠ¨ç”»å¾ªç¯
  if (window.animationFrameId) {
    cancelAnimationFrame(window.animationFrameId);
  }
  
  isSpawning = false;
  // éšè—é…ç½®é¡µé¢
  hideConfigModal();
  
  // è®°å½•æ¸¸æˆå¼€å§‹äº‹ä»¶
  versionManager.log('info', 'æ¸¸æˆå¼€å§‹', {
    gameTime: selectedTrainingTime / 1000,
    difficulty: currentDifficulty,
    version: VERSION_CONFIG.currentVersion
  });

  // æ’­æ”¾æ¸¸æˆå¼€å§‹éŸ³æ•ˆ
  soundManager.play('gameStart');
  // æ’­æ”¾èƒŒæ™¯éŸ³ä¹
  soundManager.playBackgroundMusic();
  // ä½¿ç”¨ç›‘å¬å™¨æ¥æ”¶çš„é…ç½®å‚æ•°
  gameTime = selectedTrainingTime / 1000;
  timeLeft = gameTime;
  // ç¡®ä¿éš¾åº¦è®¾ç½®æ­£ç¡®
  if (currentDifficulty) {
    setGameMode(currentDifficulty);
  }
  // é‡ç½®æ¸¸æˆçŠ¶æ€
  score = 0;
  fishes = [];
  bombs = [];
  fishCounts.fill(0);
  bombCounts = 0;
  isSpawning = false;
  isPaused = false;
  gameState = 'playing';
  // æ˜¾ç¤ºæ¸¸æˆç•Œé¢
  if (result) result.style.display = 'none';
  if (canvas) canvas.style.display = 'block';
  // å¯åŠ¨è®¡æ—¶å™¨
  if (timerTimeout) clearTimeout(timerTimeout);
  function updateTimer() {
    if (gameState !== 'playing') return;
    if (isPaused) return;
    timeLeft--;
    updateTimerDisplay();
    if (timeLeft > 0) {
      timerTimeout = setTimeout(updateTimer, 1000);
    } else {
      gameState = 'gameOver';
      showGameOver();
    }
  }
  timerTimeout = setTimeout(updateTimer, 1000);
  // å¼€å§‹ç”Ÿæˆé±¼å’Œç‚¸å¼¹
  spawnRound();
  requestAnimationFrame(gameLoop);
  updateTimerDisplay();
  clickPoints = [];
  updateInfoBar();
}
function handleClick(x, y) {
  let hit = false;
  let hitType = null;
  let scoreChange = 0;
  const JUDGE_RADIUS = 50; // åˆ¤å®šåŠå¾„50åƒç´ 

  // æ”¶é›†æ‰€æœ‰è¢«ç‚¹ä¸­çš„é±¼å’Œç‚¸å¼¹ï¼Œè®°å½•ç±»å‹å’Œç´¢å¼•
  let hitCandidates = [];
  fishes.forEach((f, idx) => {
    if (!f.clicked && x >= f.x && x <= f.x + f.width && y >= f.y && y <= f.y + f.height) {
      // è®¡ç®—ä¸­å¿ƒç‚¹è·ç¦»
      const centerX = f.x + f.width/2;
      const centerY = f.y + f.height/2;
      const dx = x - centerX;
      const dy = y - centerY;
      const distance = Math.sqrt(dx * dx + dy * dy);
      hitCandidates.push({
        type: 'fish',
        obj: f,
        idx: idx,
        drawOrder: idx, // é±¼å…ˆç»˜åˆ¶
        distance: distance
      });
    }
  });
  bombs.forEach((b, idx) => {
    if (!b.clicked && x >= b.x && x <= b.x + b.width && y >= b.y && y <= b.y + b.height) {
      const centerX = b.x + b.width/2;
      const centerY = b.y + b.height/2;
      const dx = x - centerX;
      const dy = y - centerY;
      const distance = Math.sqrt(dx * dx + dy * dy);
      hitCandidates.push({
        type: 'bomb',
        obj: b,
        idx: idx,
        drawOrder: fishes.length + idx, // ç‚¸å¼¹åç»˜åˆ¶
        distance: distance
      });
    }
  });

  // åªå¤„ç†è·ç¦»ç‚¹å‡»ç‚¹æœ€è¿‘ä¸”è·ç¦»å°äºç­‰äºJUDGE_RADIUSçš„é‚£ä¸€æ¡
  if (hitCandidates.length > 0) {
    // æ‰¾åˆ°è·ç¦»æœ€è¿‘çš„
    let closest = hitCandidates.reduce((prev, curr) =>
      curr.distance < prev.distance ? curr : prev
    );
    if (closest.distance <= JUDGE_RADIUS) {
      // å¦‚æœæœ‰å¤šä¸ªè·ç¦»ä¸€æ ·ï¼Œé€‰drawOrderå¤§çš„ï¼ˆè§†è§‰ä¸Šæœ€ä¸Šé¢ï¼‰
      let topCandidates = hitCandidates.filter(c => c.distance === closest.distance);
      let topObj = topCandidates.reduce((prev, curr) =>
        curr.drawOrder > prev.drawOrder ? curr : prev
      );
      if (topObj.type === 'fish') {
        const f = topObj.obj;
        f.clicked = true;
        score += 10;
        hit = true;
        hitType = 'fish';
        scoreChange = 10;
        const fishIndex = fishImages.indexOf(f.img);
        if (fishIndex !== -1 && fishIndex < 7) {
          fishCounts[fishIndex]++;
        }
        scorePopups.push({
          x: f.x + f.width/2,
          y: f.y,
          text: '+10',
          alpha: 1
        });
        clickPoints.push({x, y});
        soundManager.play('fishHit');
      } else if (topObj.type === 'bomb') {
        const b = topObj.obj;
        b.clicked = true;
        score -= 50;
        hit = true;
        hitType = 'bomb';
        scoreChange = -50;
        bombCounts++;
        scorePopups.push({
          x: b.x + b.width/2,
          y: b.y,
          text: '-50',
          alpha: 1,
          color: 'red'
        });
        soundManager.play('bombHit');
      }
    }
  }

  if (hit) {
    versionManager.log('debug', 'ç‚¹å‡»äº‹ä»¶', {
      x: x,
      y: y,
      hitType: hitType,
      scoreChange: scoreChange,
      newScore: score,
      version: VERSION_CONFIG.currentVersion
    });
  }

  updateInfoBar();
  return hit;
}

let lastTouchTime = 0;
function handleClickWithLock(x, y) {
  const now = Date.now();
  if (now - lastTouchTime < 150) return; // 150mså†…åªå¤„ç†ä¸€æ¬¡
  lastTouchTime = now;
  handleClick(x, y);
}

let lastClickPos = {x: null, y: null, time: 0};
function handleClickWithDedup(x, y) {
  const now = Date.now();
  if (lastClickPos.x === x && lastClickPos.y === y && now - lastClickPos.time < 100) return;
  lastClickPos = {x, y, time: now};
  handleClick(x, y);
}

let clickPointsThisFrame = [];
function isNearAnyPoint(x, y, points, radius = 10) {
  return points.some(pt => {
    const dx = pt.x - x;
    const dy = pt.y - y;
    return dx * dx + dy * dy <= radius * radius;
  });
}
function handleClickWithAreaDedup(x, y) {
  if (isNearAnyPoint(x, y, clickPointsThisFrame, 50)) return;
  clickPointsThisFrame.push({x, y});
  handleClick(x, y);
}
function clearClickPointsThisFrame() {
  clickPointsThisFrame = [];
  requestAnimationFrame(clearClickPointsThisFrame);
}
clearClickPointsThisFrame();

const CLICK_DEDUP_RADIUS = 50;
const CLICK_DEDUP_FRAMES = 3; // 3å¸§å†…åŒä¸€ä½ç½®åªæ¶ˆå¤±ä¸€æ¡
let clickPointsHistory = Array.from({length: CLICK_DEDUP_FRAMES}, () => []);

function isNearAnyPoint(x, y, points, radius = CLICK_DEDUP_RADIUS) {
  return points.some(pt => {
    const dx = pt.x - x;
    const dy = pt.y - y;
    return dx * dx + dy * dy <= radius * radius;
  });
}

function handleClickWithMultiFrameDedup(x, y) {
  // æ£€æŸ¥æœ€è¿‘Nå¸§å†…æ˜¯å¦å·²å¤„ç†è¿‡
  for (let i = 0; i < clickPointsHistory.length; i++) {
    if (isNearAnyPoint(x, y, clickPointsHistory[i], CLICK_DEDUP_RADIUS)) return;
  }
  // è®°å½•åˆ°æœ¬å¸§
  clickPointsHistory[clickPointsHistory.length - 1].push({x, y});
  handleClick(x, y);
}

// æ¯å¸§æ¨è¿›å†å²
function advanceClickPointsHistory() {
  clickPointsHistory.shift();
  clickPointsHistory.push([]);
  requestAnimationFrame(advanceClickPointsHistory);
}
advanceClickPointsHistory();

canvas.addEventListener('mousedown', e => {
  if (gameState !== 'playing') return;
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  const x = (e.clientX - rect.left) * scaleX;
  const y = (e.clientY - rect.top) * scaleY;
  handleClickWithMultiFrameDedup(x, y);
});
canvas.addEventListener('touchend', e => {
  if (gameState !== 'playing') return;
  for (let i = 0; i < e.changedTouches.length; i++) {
    const touch = e.changedTouches[i];
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    const x = (touch.clientX - rect.left) * scaleX;
    const y = (touch.clientY - rect.top) * scaleY;
    handleClickWithMultiFrameDedup(x, y);
  }
});

window.onload = () => {
  // è®°å½•é¡µé¢åŠ è½½å®Œæˆäº‹ä»¶
  versionManager.log('info', 'é¡µé¢åŠ è½½å®Œæˆ', {
    userAgent: navigator.userAgent,
    screenSize: `${screen.width}x${screen.height}`,
    version: VERSION_CONFIG.currentVersion,
    buildDate: VERSION_CONFIG.buildDate
  });

  console.log('é¡µé¢åŠ è½½å®Œæˆï¼Œç­‰å¾…é…ç½®å‚æ•°...');
  // åˆå§‹åŒ–æ¸¸æˆå¾ªç¯ï¼Œç”¨äºæ˜¾ç¤ºæ°”çƒå’Œäº‘
  gameTimeout = setTimeout(() => {
    update();
    draw();
  }, 30);
};

// ä¿®æ”¹é‡ç½®æ¸¸æˆå‡½æ•°
function resetGame() {
  // åœæ­¢æ‰€æœ‰å®šæ—¶å™¨å’ŒåŠ¨ç”»å¸§
  if (window.timerTimeout) {
    clearTimeout(window.timerTimeout);
    window.timerTimeout = null;
  }
  if (window.spawnTimeouts && Array.isArray(window.spawnTimeouts)) {
    window.spawnTimeouts.forEach(id => clearTimeout(id));
    window.spawnTimeouts = [];
  }
  if (window.animationFrameId) {
    cancelAnimationFrame(window.animationFrameId);
    window.animationFrameId = null;
  }

  // æ¸…ç©ºæ‰€æœ‰å…¨å±€å˜é‡å’Œæ•°ç»„
  score = 0;
  lives = 3;
  gameTime = 0;
  timeLeft = 0;
  fishes = [];
  bombs = [];
  balloons = [];
  fishCounts = Array(7).fill(0);
  bombCounts = 0;
  clickPoints = [];
  isPaused = false;
  isSpawning = false;
  gameState = 'config';
  roundInterval = 3000;
  balloonTimer = 0;
  bombTimer = 0;
  startTime = 0;
  selectedTrainingTime = 10 * 60000;
  currentDifficulty = 'normal';

  // æ¸…ç©ºCanvas
  if (typeof ctx !== 'undefined' && ctx && typeof canvas !== 'undefined' && canvas) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
  }

  // éšè—æ‰€æœ‰å¼¹çª—
  const modals = document.querySelectorAll('.modal, #gameOverModal, #pauseModal, #ruleModal, #result, #reportModal');
  modals.forEach(m => m.style.display = 'none');
  // ç§»é™¤åŠ¨æ€åˆ›å»ºçš„gameOverModal
  const gameOverModal = document.getElementById('gameOverModal');
  if (gameOverModal) gameOverModal.remove();

  // æ¢å¤åˆå§‹ç•Œé¢
  showConfigModal();
  if (typeof updateInfoBar === 'function') updateInfoBar();

  // é‡æ–°å¯åŠ¨ä¸»å¾ªç¯
  if (typeof gameLoop === 'function') {
    window.animationFrameId = requestAnimationFrame(gameLoop);
  }
}

// ä¿®æ”¹æ˜¾ç¤ºæ¸¸æˆç»“æŸå‡½æ•°
function showGameOver() {
  // è®°å½•æ¸¸æˆç»“æŸè¯¦ç»†ä¿¡æ¯
  versionManager.log('info', 'æ˜¾ç¤ºæ¸¸æˆç»“æŸç•Œé¢', {
    score: score,
    clickPoints: clickPoints.length,
    version: VERSION_CONFIG.currentVersion,
    buildHash: VERSION_CONFIG.buildHash
  });

  // æ’­æ”¾æ¸¸æˆç»“æŸéŸ³æ•ˆ
  soundManager.play('gameOver');
  
  // åœæ­¢èƒŒæ™¯éŸ³ä¹
  soundManager.stopBackgroundMusic();

  gameState = 'gameOver';
  if (timerTimeout) {
    clearTimeout(timerTimeout);
    timerTimeout = null;
  }
  startTime = 0;
  
  const now = new Date();
  const pad = n => n.toString().padStart(2, '0');
  const timeStr = `${now.getFullYear()}-${pad(now.getMonth()+1)}-${pad(now.getDate())} ${pad(now.getHours())}:${pad(now.getMinutes())}:${pad(now.getSeconds())}`;
  
  // ä½¿ç”¨ç›‘å¬å™¨æ¥æ”¶çš„æ—¶é—´é…ç½®
  const durationMinutes = Math.floor(selectedTrainingTime / 60000);
  const duration = durationMinutes.toString().padStart(2, '0') + ':00';
  const heatmapUrl = generateHeatmap(clickPoints);
  


  // æ˜¾ç¤ºæ¸¸æˆç»“æŸç•Œé¢
  showGameOverModal();
  updateInfoBar();
}

function showGameOverModal() {
  // åˆ›å»ºæ¸¸æˆç»“æŸå¼¹çª—
  const gameOverModal = document.createElement('div');
  gameOverModal.id = 'gameOverModal';
  gameOverModal.style.cssText = `
    position: fixed;
    left: 0;
    top: 0;
    width: 100vw;
    height: 100vh;
    background: rgba(0, 0, 0, 0.8);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 6000;
  `;
  
  const gameOverContent = document.createElement('div');
  gameOverContent.style.cssText = `
    background: #f8f6f2;
    border-radius: 12px;
    width: 500px;
    padding: 40px;
    text-align: center;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
  `;
  
  gameOverContent.innerHTML = `
    <h2 style="color: #333; margin-bottom: 20px;">æ¸¸æˆç»“æŸ</h2>
    <p style="font-size: 1.2rem; color: #555; margin-bottom: 30px;">æœ€ç»ˆå¾—åˆ†: <span style="color: #0099ff; font-weight: bold;">${score}</span></p>
    <button id="restartGameBtn" style="
      padding: 12px 30px;
      background: #0099ff;
      color: #fff;
      border: none;
      border-radius: 8px;
      font-size: 1.1rem;
      cursor: pointer;
      margin-right: 15px;
    ">é‡æ–°å¼€å§‹</button>
    <button id="exitGameBtn" style="
      padding: 12px 30px;
      background: #666;
      color: #fff;
      border: none;
      border-radius: 8px;
      font-size: 1.1rem;
      cursor: pointer;
    ">é€€å‡ºæ¸¸æˆ</button>
  `;
  
  gameOverModal.appendChild(gameOverContent);
  document.body.appendChild(gameOverModal);
  
  // ç»‘å®šæŒ‰é’®äº‹ä»¶
  document.getElementById('restartGameBtn').addEventListener('click', function() {
    // æ’­æ”¾æŒ‰é’®ç‚¹å‡»éŸ³æ•ˆ
    soundManager.play('buttonClick');
    
    // ç§»é™¤æ¸¸æˆç»“æŸå¼¹çª—
    document.body.removeChild(gameOverModal);
    
    // æ¸…ç†æ‰€æœ‰å®šæ—¶å™¨
    if (timerTimeout) {
      clearTimeout(timerTimeout);
      timerTimeout = null;
    }
    clearSpawnTimeouts();
    
    // åœæ­¢èƒŒæ™¯éŸ³ä¹
    soundManager.stopBackgroundMusic();
    
    // é‡ç½®æ¸¸æˆçŠ¶æ€
    isPaused = false;
    gameState = 'config';
    
    // æ˜¾ç¤ºé…ç½®é¡µé¢é‡æ–°å¼€å§‹
    showConfigModal();
    
    // è®°å½•é‡æ–°å¼€å§‹æ“ä½œ
    versionManager.log('info', 'ç”¨æˆ·ä»æ¸¸æˆç»“æŸç•Œé¢é‡æ–°å¼€å§‹', {
      previousScore: score,
      timeLeft: timeLeft,
      timestamp: new Date().toISOString(),
      version: VERSION_CONFIG.currentVersion
    });
  });
  
  document.getElementById('exitGameBtn').addEventListener('click', function() {
    // æ’­æ”¾æŒ‰é’®ç‚¹å‡»éŸ³æ•ˆ
    soundManager.play('buttonClick');
    
    // ç§»é™¤æ¸¸æˆç»“æŸå¼¹çª—
    document.body.removeChild(gameOverModal);
    
    // æ¸…ç†æ‰€æœ‰å®šæ—¶å™¨
    if (timerTimeout) {
      clearTimeout(timerTimeout);
      timerTimeout = null;
    }
    clearSpawnTimeouts();
    
    // åœæ­¢èƒŒæ™¯éŸ³ä¹
    soundManager.stopBackgroundMusic();
    
    // è®°å½•é€€å‡ºæ“ä½œ
    versionManager.log('info', 'ç”¨æˆ·ä»æ¸¸æˆç»“æŸç•Œé¢é€€å‡ºæ¸¸æˆ', {
      finalScore: score,
      timestamp: new Date().toISOString(),
      version: VERSION_CONFIG.currentVersion
    });
    
    // å°è¯•å¤šç§æ–¹å¼å…³é—­çª—å£
    try {
      // æ–¹æ³•1: å°è¯•å…³é—­å½“å‰çª—å£
      if (window.opener) {
        window.close();
      } else {
        // æ–¹æ³•2: å¦‚æœæ²¡æœ‰openerï¼Œå°è¯•ä½¿ç”¨location.href
        window.location.href = 'about:blank';
      }
      
      // æ–¹æ³•3: å»¶è¿Ÿåå¼ºåˆ¶å…³é—­
      setTimeout(() => {
        window.close();
        // å¦‚æœè¿˜æ˜¯æ— æ³•å…³é—­ï¼Œæ˜¾ç¤ºæç¤º
        if (!window.closed) {
          alert('è¯·æ‰‹åŠ¨å…³é—­æ­¤çª—å£');
        }
      }, 100);
      
    } catch (error) {
      console.warn('å…³é—­çª—å£å¤±è´¥:', error);
      // æœ€åçš„å¤‡é€‰æ–¹æ¡ˆ
      window.location.href = 'about:blank';
    }
  });
}

// ä¿®æ”¹æ›´æ–°è®¡æ—¶å™¨æ˜¾ç¤ºå‡½æ•°
function updateTimerDisplay() {
  const t = i18nText[window.currentLang] || i18nText['en-US'];
  const minutes = Math.floor(timeLeft / 60);
  const seconds = timeLeft % 60;
  // åªæ›´æ–°canvasä¸Šçš„è®¡æ—¶å™¨æ˜¾ç¤ºï¼Œä¸å†æ›´æ–°timerDisplayå…ƒç´ 
  ctx.fillStyle = 'black';
  ctx.font = '48px sans-serif';
  ctx.textAlign = 'left';
  
  updateInfoBar();
}

function updateBomb(bomb) {
  // æ£€æŸ¥æ˜¯å¦è¾¾åˆ°æœ€é«˜ç‚¹ï¼ˆvyä»è´Ÿå˜ä¸ºæ­£çš„æ—¶åˆ»ï¼‰
  if (!bomb.hasPausedAtTop && bomb.lastVy < 0 && bomb.vy >= 0) {
    bomb.hasPausedAtTop = true;
    bomb.isPaused = true; // å¼€å§‹æš‚åœ
    bomb.pauseTimer = 0; // é‡ç½®æš‚åœè®¡æ—¶å™¨
    bomb.originalVx = bomb.vx; // ä¿å­˜åŸå§‹æ°´å¹³é€Ÿåº¦
    bomb.vx = 0; // åœ¨æœ€é«˜ç‚¹æ—¶å–æ¶ˆæ°´å¹³é€Ÿåº¦
  }
  
  // å¤„ç†æš‚åœé€»è¾‘
  if (bomb.isPaused) {
    bomb.pauseTimer += 16; // å‡è®¾60fpsï¼Œæ¯å¸§çº¦16ms
    if (bomb.pauseTimer >= 100) { // 0.1ç§’ = 100ms
      bomb.isPaused = false; // ç»“æŸæš‚åœ
      bomb.vx = bomb.originalVx; // æ¢å¤åŸå§‹æ°´å¹³é€Ÿåº¦
    } else {
      // æš‚åœæœŸé—´åªæœ‰å‚ç›´è¿åŠ¨ï¼Œæ²¡æœ‰æ°´å¹³è¿åŠ¨
      bomb.vy += GRAVITY * 0.8;
      bomb.y += bomb.vy;
      return; // æš‚åœæœŸé—´è·³è¿‡å…¶ä»–ä½ç½®æ›´æ–°
    }
  }
  
  bomb.lastVy = bomb.vy;
  bomb.vy += GRAVITY;
  bomb.x += bomb.vx;
  bomb.y += bomb.vy;
  
  // å¦‚æœç‚¸å¼¹é£å‡ºå±å¹•æˆ–è½å›åœ°é¢ï¼Œåˆ™ç§»é™¤
  if (bomb.y > canvas.height || bomb.y < -bomb.height) {
    const index = bombs.indexOf(bomb);
    if (index > -1) {
      bombs.splice(index, 1);
    }
  }
}

// ç”Ÿæˆæ°”çƒ
function spawnBalloon() {
  if (gameState === 'playing') {
    const balloon = {
      x: canvas.width * 0.618, // ä½¿ç”¨é»„é‡‘åˆ†å‰²ç‚¹ä½ç½®
      y: canvas.height + 50, // ä»åº•éƒ¨å‡èµ·
      vy: -1.5, // é™ä½ä¸Šå‡é€Ÿåº¦åˆ°1.5
      img: balloon1Img,
      width: 300, // å¢åŠ æ°”çƒå®½åº¦åˆ°300
      height: 450 // å¢åŠ æ°”çƒé«˜åº¦åˆ°450ï¼Œä¿æŒå®½é«˜æ¯”
    };
    
    balloons.push(balloon);
  }
}

// æ›´æ–°æ°”çƒ
function updateBalloon(balloon) {
  balloon.y += balloon.vy;
  // å¦‚æœæ°”çƒé£å‡ºå±å¹•é¡¶éƒ¨ï¼Œé‡æ–°ä»åº•éƒ¨ç”Ÿæˆ
  if (balloon.y < -balloon.height) {
    // ç§»é™¤å½“å‰æ°”çƒ
    const index = balloons.indexOf(balloon);
    if (index > -1) {
      balloons.splice(index, 1);
    }
    // ç”Ÿæˆæ–°çš„æ°”çƒ
    spawnBalloon();
  }
}

// è®¾ç½®æ¸¸æˆæ¨¡å¼
function setGameMode(mode) {
  gameMode = mode;
  // æ ¹æ®æ¨¡å¼è®¾ç½®ç‚¸å¼¹æ•°é‡å’Œæ¯è½®é—´éš”
  switch(mode) {
    case 'easy':
      bombCount = 1;
      difficulty = 'easy';
      roundInterval = 3500;
      break;
    case 'normal':
      bombCount = 2;
      difficulty = 'normal';
      roundInterval = 2500;
      break;
    case 'hard':
      bombCount = 3;
      difficulty = 'hard';
      roundInterval = 1500;
      break;
  }
  console.log(`è®¾ç½®æ¸¸æˆæ¨¡å¼ä¸º: ${mode}, ç‚¸å¼¹æ•°é‡: ${bombCount}, æ¯è½®é—´éš”: ${roundInterval}ms`); // æ·»åŠ æ—¥å¿—
}

function showReportModal(data) {
  const t = i18nText[window.currentLang] || i18nText['en-US'];
  document.getElementById('userName').value = data.name || '';
  document.getElementById('userGender').value = data.gender || '';
  document.getElementById('userAge').value = data.age || '';
  document.getElementById('userId').value = data.id || '';
  document.getElementById('trainName').innerText = t.gameName;
  document.getElementById('trainDuration').innerText = data.duration || '01:00';
  document.getElementById('trainStart').innerText = data.startTime || '';
  document.getElementById('trainScore').innerText = data.score || '0';
  document.getElementById('reportImage').src = data.image || 'assets/1.jpg';
  document.getElementById('reportModal').style.display = 'flex';
}
function closeReport() {
  document.getElementById('reportModal').style.display = 'none';
}
function saveReport() { alert('ä¿å­˜æˆåŠŸï¼'); }
function printReport() { window.print(); }

function generateHeatmap(points) {
  const canvas = document.getElementById('heatmapCanvas');
  const ctx = canvas.getContext('2d');
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  points.forEach(pt => {
    const gradient = ctx.createRadialGradient(pt.x, pt.y, 0, pt.x, pt.y, 60);
    gradient.addColorStop(0, 'rgba(255,0,0,0.4)');
    gradient.addColorStop(1, 'rgba(255,0,0,0)');
    ctx.beginPath();
    ctx.arc(pt.x, pt.y, 60, 0, 2 * Math.PI);
    ctx.fillStyle = gradient;
    ctx.fill();
  });
  return canvas.toDataURL('image/png');
}

// åˆå§‹åŒ–å‡½æ•°ï¼Œæ˜¾ç¤ºä¸»èœå•
function init() {
    showConfigModal();
}

// ç”Ÿæˆç¬¦åˆåç«¯è¦æ±‚çš„æ•°æ®æ ¼å¼


// è·å–éš¾åº¦æ–‡æœ¬
function getDifficultyText(difficulty) {
    switch(difficulty) {
        case 'easy': return 'ç®€å•';
        case 'normal': return 'æ™®é€š';
        case 'hard': return 'å›°éš¾';
        default: return 'æ™®é€š';
    }
}

// ç”ŸæˆKDE+é«˜æ–¯æ¨¡ç³Šçƒ­åŠ›å›¾æ•°æ®ï¼Œåˆ†è¾¨ç‡æ˜ å°„+å½’ä¸€åŒ–åˆ°0~7ï¼Œè¾“å‡ºä¸‰å…ƒç»„
function generateHeatmapData(points) {
    const t = i18nText[window.currentLang] || i18nText['en-US'];
    const gridWidth = 320;
    const gridHeight = 180;
    const canvasWidth = canvas.width;
    const canvasHeight = canvas.height;

    // 1. åˆ†è¾¨ç‡æ˜ å°„
    const scaleX = gridWidth / canvasWidth;
    const scaleY = gridHeight / canvasHeight;
    const mappedPoints = points.map(p => ({
        x: p.x * scaleX,
        y: (canvasHeight - p.y) * scaleY // ä¿®æ­£yè½´æ–¹å‘
    }));

    // 2. KDE+é«˜æ–¯æ¨¡ç³Š
    function applyKernelDensityEstimation(positions, width, height) {
        const grid = Array(width).fill(0).map(() => Array(height).fill(0));
        const kernelRadius = 10;
        const kernelRadiusSq = kernelRadius * kernelRadius;
        const gaussianKernel = (distanceSq) => Math.exp(-distanceSq / (2 * kernelRadiusSq));
        for (const pos of positions) {
            const minX = Math.max(0, Math.floor(pos.x - kernelRadius));
            const maxX = Math.min(width - 1, Math.ceil(pos.x + kernelRadius));
            const minY = Math.max(0, Math.floor(pos.y - kernelRadius));
            const maxY = Math.min(height - 1, Math.ceil(pos.y + kernelRadius));
            for (let x = minX; x <= maxX; x++) {
                for (let y = minY; y <= maxY; y++) {
                    const dx = x - pos.x;
                    const dy = y - pos.y;
                    const distanceSq = dx * dx + dy * dy;
                    if (distanceSq <= kernelRadiusSq) {
                        grid[x][y] += gaussianKernel(distanceSq);
                    }
                }
            }
        }
        return applySeparableGaussianBlur(grid, 5);
    }

    function applySeparableGaussianBlur(grid, kernelSize) {
        const width = grid.length;
        const height = grid[0].length;
        const tempGrid = Array(width).fill(0).map(() => Array(height).fill(0));
        const kernel = createGaussianKernel(kernelSize);
        const radius = Math.floor(kernelSize / 2);
        // æ°´å¹³æ¨¡ç³Š
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                let sum = 0;
                let weightSum = 0;
                for (let i = -radius; i <= radius; i++) {
                    const nx = x + i;
                    if (nx >= 0 && nx < width) {
                        const weight = kernel[i + radius];
                        sum += grid[nx][y] * weight;
                        weightSum += weight;
                    }
                }
                tempGrid[x][y] = sum / weightSum;
            }
        }
        // å‚ç›´æ¨¡ç³Š
        const resultGrid = Array(width).fill(0).map(() => Array(height).fill(0));
        for (let x = 0; x < width; x++) {
            for (let y = 0; y < height; y++) {
                let sum = 0;
                let weightSum = 0;
                for (let j = -radius; j <= radius; j++) {
                    const ny = y + j;
                    if (ny >= 0 && ny < height) {
                        const weight = kernel[j + radius];
                        sum += tempGrid[x][ny] * weight;
                        weightSum += weight;
                    }
                }
                resultGrid[x][y] = sum / weightSum;
            }
        }
        return resultGrid;
    }

    function createGaussianKernel(size) {
        const kernel = [];
        const radius = Math.floor(size / 2);
        let sum = 0;
        const sigma = radius / 2;
        const twoSigmaSq = 2 * sigma * sigma;
        for (let i = -radius; i <= radius; i++) {
            const value = Math.exp(-(i * i) / twoSigmaSq);
            kernel.push(value);
            sum += value;
        }
        return kernel.map(v => v / sum);
    }

    // å¤„ç†æ— æ•°æ®æƒ…å†µ
    if (!points || points.length === 0) {
        let data = [];
        for (let x = 0; x < gridWidth; x++) {
            for (let y = 0; y < gridHeight; y++) {
                data.push([x, y, 0]);
            }
        }
        return {
            type: 'heatmap',
            name: t.heatmap,
            data
        };
    }

    const smoothedGrid = applyKernelDensityEstimation(mappedPoints, gridWidth, gridHeight);

    // 3. å½’ä¸€åŒ–åˆ°0~7
    let maxDensity = 0;
    for (let x = 0; x < gridWidth; x++) {
        for (let y = 0; y < gridHeight; y++) {
            if (smoothedGrid[x][y] > maxDensity) {
                maxDensity = smoothedGrid[x][y];
            }
        }
    }

    // 4. æ‰“åŒ…ä¸‰å…ƒç»„
    let data = [];
    for (let x = 0; x < gridWidth; x++) {
        for (let y = 0; y < gridHeight; y++) {
            const normalizedValue = (maxDensity > 0 ? smoothedGrid[x][y] / maxDensity : 0) * 7;
            data.push([x, y, normalizedValue]);
        }
    }

    return {
        type: 'heatmap',
        name: t.heatmap,
        data
    };
}

// ä¸Šä¼ æ•°æ®åˆ°åç«¯




// åˆå§‹åŒ–æ¸¸æˆ
init();

// åœ¨åˆ†æ•°å’Œæ—¶é—´å˜åŒ–çš„åœ°æ–¹ï¼Œæ·»åŠ ï¼š
function updateInfoBar() {
  const t = i18nText[window.currentLang] || i18nText['en-US'];
  const scoreInfo = document.getElementById('scoreInfo');
  const timerInfo = document.getElementById('timerInfo');
  if (scoreInfo) scoreInfo.textContent = `${t.score}ï¼š${score}`;
  if (timerInfo) {
    // ä»¥selectedTrainingTimeä¸ºæ€»æ—¶é•¿ï¼ŒtimeLeftä¸ºå‰©ä½™ç§’æ•°
    const min = Math.floor(timeLeft / 60).toString().padStart(2, '0');
    const sec = (timeLeft % 60).toString().padStart(2, '0');
    timerInfo.textContent = `${t.time}ï¼š${min}:${sec}`;
  }
}
// åœ¨åˆ†æ•°å˜åŒ–ï¼ˆå¦‚åŠ åˆ†ã€æ‰£åˆ†ã€resetGameã€startGameç­‰ï¼‰å’Œå€’è®¡æ—¶å˜åŒ–ï¼ˆupdateTimerDisplayï¼‰å¤„è°ƒç”¨updateInfoBar() 

// 1. å®šä¹‰æš‚åœUIæ§åˆ¶å‡½æ•°
function setPauseUI(show) {
  const pauseModal = document.getElementById('pauseModal');
  if (pauseModal) pauseModal.style.display = show ? 'flex' : 'none';
}

// 2. ç»‘å®šæš‚åœæŒ‰é’®å’Œæš‚åœç•Œé¢æŒ‰é’®äº‹ä»¶

document.addEventListener('DOMContentLoaded', function() {
  console.log('[è°ƒè¯•] DOMContentLoaded äº‹ä»¶å·²è§¦å‘');
  const stopBtn = document.getElementById('stopBtn');
  console.log('[è°ƒè¯•] stopBtn:', stopBtn);
  if (stopBtn) {
    stopBtn.onclick = function() {
      soundManager.play('pause');
      isPaused = true;
      if (timerTimeout) {
        clearTimeout(timerTimeout);
        timerTimeout = null;
      }
      clearSpawnTimeouts(); // æ–°å¢
      document.getElementById('pauseModal').style.display = 'flex';
      soundManager.pauseBackgroundMusic(); // æš‚åœèƒŒæ™¯éŸ³ä¹
    };
    console.log('[è°ƒè¯•] stopBtn äº‹ä»¶ç»‘å®šå®Œæˆ');
  }
  // ç»§ç»­æŒ‰é’®
  const resumeBtn = document.getElementById('resumeBtn');
  if (resumeBtn) {
    resumeBtn.onclick = function() {
      soundManager.play('resume');
      isPaused = false;
      document.getElementById('pauseModal').style.display = 'none';
      if (timerTimeout === null && timeLeft > 0 && gameState === 'playing') {
        function updateTimer() {
          if (gameState !== 'playing' || isPaused) return;
          timeLeft--;
          updateTimerDisplay();
          if (timeLeft > 0) {
            timerTimeout = setTimeout(updateTimer, 1000);
          } else {
            gameState = 'gameOver';
            showGameOver();
          }
        }
        timerTimeout = setTimeout(updateTimer, 1000);
      }
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      draw();
      requestAnimationFrame(gameLoop);
      soundManager.resumeBackgroundMusic();
      isSpawning = false; // åªä¿ç•™è¿™å¥
      // spawnRound();  // è¿™ä¸€å¥åˆ æ‰
    };
  }

  // é‡åšæŒ‰é’®
  const restartBtn = document.getElementById('restartBtn');
  if (restartBtn) {
    restartBtn.onclick = function() {
      // æ’­æ”¾æŒ‰é’®ç‚¹å‡»éŸ³æ•ˆ
      soundManager.play('buttonClick');
      
      // æ¸…ç†æ‰€æœ‰å®šæ—¶å™¨
      if (timerTimeout) {
        clearTimeout(timerTimeout);
        timerTimeout = null;
      }
      clearSpawnTimeouts();
      
      // åœæ­¢èƒŒæ™¯éŸ³ä¹
      soundManager.stopBackgroundMusic();
      
      // éšè—æš‚åœå¼¹çª—
      const pauseModal = document.getElementById('pauseModal');
      if (pauseModal) pauseModal.style.display = 'none';
      
      // é‡ç½®æ¸¸æˆçŠ¶æ€
      isPaused = false;
      gameState = 'config';
      
      // æ˜¾ç¤ºé…ç½®é¡µé¢é‡æ–°å¼€å§‹
      showConfigModal();
      
      // è®°å½•é‡åšæ“ä½œ
      versionManager.log('info', 'ç”¨æˆ·ç‚¹å‡»é‡åšæŒ‰é’®', {
        previousGameState: gameState,
        timeLeft: timeLeft,
        score: score,
        timestamp: new Date().toISOString(),
        version: VERSION_CONFIG.currentVersion
      });
    };
  }

  // é€€å‡ºæŒ‰é’®
  const exitBtn = document.getElementById('exitBtn');
  if (exitBtn) {
    exitBtn.onclick = function() {
      // æ’­æ”¾æŒ‰é’®ç‚¹å‡»éŸ³æ•ˆ
      soundManager.play('buttonClick');
      
      // 1. éšè—æš‚åœå¼¹çª—
      const pauseModal = document.getElementById('pauseModal');
      if (pauseModal) pauseModal.style.display = 'none';
      
      // æ¸…ç†æ‰€æœ‰å®šæ—¶å™¨
      if (timerTimeout) {
        clearTimeout(timerTimeout);
        timerTimeout = null;
      }
      clearSpawnTimeouts();
      
      // åœæ­¢èƒŒæ™¯éŸ³ä¹
      soundManager.stopBackgroundMusic();
      
      // è®°å½•é€€å‡ºæ“ä½œ
      versionManager.log('info', 'ç”¨æˆ·ä»æš‚åœç•Œé¢é€€å‡ºæ¸¸æˆ', {
        currentScore: score,
        timeLeft: timeLeft,
        timestamp: new Date().toISOString(),
        version: VERSION_CONFIG.currentVersion
      });
      
      // å°è¯•å¤šç§æ–¹å¼å…³é—­çª—å£
      try {
        // æ–¹æ³•1: å°è¯•å…³é—­å½“å‰çª—å£
        if (window.opener) {
          window.close();
        } else {
          // æ–¹æ³•2: å¦‚æœæ²¡æœ‰openerï¼Œå°è¯•ä½¿ç”¨location.href
          window.location.href = 'about:blank';
        }
        
        // æ–¹æ³•3: å»¶è¿Ÿåå¼ºåˆ¶å…³é—­
        setTimeout(() => {
          window.close();
          // å¦‚æœè¿˜æ˜¯æ— æ³•å…³é—­ï¼Œæ˜¾ç¤ºæç¤º
          if (!window.closed) {
            alert('è¯·æ‰‹åŠ¨å…³é—­æ­¤çª—å£');
          }
        }, 100);
        
      } catch (error) {
        console.warn('å…³é—­çª—å£å¤±è´¥:', error);
        // æœ€åçš„å¤‡é€‰æ–¹æ¡ˆ
        window.location.href = 'about:blank';
      }
    };
  }



  // è§„åˆ™è¯´æ˜æŒ‰é’®
  const explainBtn = document.getElementById('explainBtn');
  if (explainBtn) {
    explainBtn.onclick = function() {
      // æ’­æ”¾æŒ‰é’®ç‚¹å‡»éŸ³æ•ˆ
      soundManager.play('buttonClick');
      // æš‚åœæ¸¸æˆçŠ¶æ€
      isPaused = true;
      // æš‚åœè®¡æ—¶å™¨
      if (timerTimeout) {
        clearTimeout(timerTimeout);
        timerTimeout = null;
      }
      clearSpawnTimeouts(); // æ–°å¢
      // æš‚åœèƒŒæ™¯éŸ³ä¹
      soundManager.pauseBackgroundMusic();
      // æ˜¾ç¤ºè§„åˆ™å¼¹çª—
      document.getElementById('ruleModal').style.display = 'flex';
      // è®°å½•è§„åˆ™å¼¹çª—æ‰“å¼€æ—¥å¿—
      versionManager.log('info', 'è§„åˆ™å¼¹çª—å·²æ‰“å¼€ï¼Œæ¸¸æˆå·²æš‚åœ', {
        currentGameState: gameState,
        timeLeft: timeLeft,
        isPaused: isPaused,
        timerActive: !!timerTimeout,
        backgroundMusic: !soundManager.isSoundMuted(),
        timestamp: new Date().toISOString(),
        version: VERSION_CONFIG.currentVersion
      });
    };
  }
  // è§„åˆ™å¼¹çª—è¿”å›æŒ‰é’®
  const ruleBackBtn = document.getElementById('ruleBackBtn');
  if (ruleBackBtn) {
    ruleBackBtn.onclick = function() {
      soundManager.play('buttonClick');
      document.getElementById('ruleModal').style.display = 'none';
      // æ¢å¤æ¸¸æˆçŠ¶æ€
      isPaused = false;
      versionManager.log('info', 'è§„åˆ™å¼¹çª—å·²å…³é—­ï¼Œæ¢å¤æ¸¸æˆ', {
        currentGameState: gameState,
        timeLeft: timeLeft,
        isPaused: isPaused,

        timestamp: new Date().toISOString(),
        version: VERSION_CONFIG.currentVersion
      });
      if (gameState === 'playing' && timeLeft > 0) {
        if (timerTimeout === null) {
          function updateTimer() {
            if (gameState !== 'playing' || isPaused) return;
            timeLeft--;
            updateTimerDisplay();
            updateInfoBar();
            if (timeLeft > 0) {
              timerTimeout = setTimeout(updateTimer, 1000);
            } else {
              gameState = 'gameOver';
              showGameOver();
            }
          }
          timerTimeout = setTimeout(updateTimer, 1000);
          versionManager.log('info', 'è®¡æ—¶å™¨å·²æ¢å¤', {
            timeLeft: timeLeft,
            timerTimeout: !!timerTimeout,
            timestamp: new Date().toISOString(),
            version: VERSION_CONFIG.currentVersion
          });
        }
        soundManager.resumeBackgroundMusic();
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        draw();
       
        isSpawning = false; // ä¿®å¤ï¼šé‡ç½®isSpawningï¼Œä¿è¯èƒ½è‡ªåŠ¨ç”Ÿæˆä¸‹ä¸€è½®
        requestAnimationFrame(gameLoop);
        versionManager.log('info', 'æ¸¸æˆå·²æ¢å¤è¿è¡Œ', {
          gameState: gameState,
          timeLeft: timeLeft,
          timerActive: !!timerTimeout,
          backgroundMusic: !soundManager.isSoundMuted(),
          gameLoopRestarted: true,
          timestamp: new Date().toISOString(),
          version: VERSION_CONFIG.currentVersion
        });
        updateTimerDisplay();
        updateInfoBar();
        // ä¸ä¸»åŠ¨spawnRoundï¼Œç”±gameLoopè‡ªåŠ¨åˆ¤æ–­
      } else {
        versionManager.log('warn', 'æ¸¸æˆçŠ¶æ€ä¸ç¬¦åˆæ¢å¤æ¡ä»¶', {
          gameState: gameState,
          timeLeft: timeLeft,
          isPaused: isPaused,
          timestamp: new Date().toISOString(),
          version: VERSION_CONFIG.currentVersion
        });
      }
    };
  }

  // ä¸ºæ‰€æœ‰æŒ‰é’®æ·»åŠ éŸ³æ•ˆ
  const allButtons = document.querySelectorAll('button, .btn, [role="button"]');
  allButtons.forEach(button => {
    if (!button.onclick) { // åªä¸ºæ²¡æœ‰ç»‘å®šonclickçš„æŒ‰é’®æ·»åŠ éŸ³æ•ˆ
      button.addEventListener('click', function() {
        soundManager.play('buttonClick');
      });
    }
  });

  // éŸ³æ•ˆæ§åˆ¶
  const soundToggle = document.getElementById('soundToggle');
  const volumeSlider = document.getElementById('volumeSlider');
  
  if (soundToggle) {
    soundToggle.onclick = function() {
      const isMuted = soundManager.toggleMute();
      soundToggle.textContent = isMuted ? 'ğŸ”‡' : 'ğŸ”Š';
    };
  }
  
  if (volumeSlider) {
    volumeSlider.oninput = function() {
      const volume = this.value / 100;
      soundManager.setVolume(volume);
    };
  }

  // ...å…¶å®ƒæŒ‰é’®ç»‘å®š...
}); 

window.addEventListener('DOMContentLoaded', function() {
  var pauseModal = document.getElementById('pauseModal');
  if (pauseModal) pauseModal.style.display = 'none';
  var ruleModal = document.getElementById('ruleModal');
  if (ruleModal) ruleModal.style.display = 'none';
  // åªç§»åŠ¨è§„åˆ™å¼¹çª—é‡Œçš„æ–‡å­—å’Œè¿”å›æŒ‰é’®æ•´ä½“ä¸Šç§»40åƒç´ 
  var ruleText = document.querySelector('#ruleModal div[style*="font-size:1.3rem"]');
  var ruleBackBtn = document.getElementById('ruleBackBtn');
  if (ruleText && ruleBackBtn) {
    // åˆ›å»ºä¸€ä¸ªåŒ…è£¹div
    var wrapper = document.createElement('div');
    wrapper.style.position = 'relative';
    wrapper.style.top = '-40px';
    // æ’å…¥åˆ°ruleTextå‰é¢
    ruleText.parentNode.insertBefore(wrapper, ruleText);
    // æŠŠæ–‡å­—å’ŒæŒ‰é’®éƒ½ç§»åˆ°wrapperé‡Œ
    wrapper.appendChild(ruleText);
    wrapper.appendChild(ruleBackBtn);
  }
  
  // ç»‘å®šé…ç½®é¡µé¢äº‹ä»¶
  const startGameBtn = document.getElementById('startGameBtn');
  if (startGameBtn) {
    startGameBtn.addEventListener('click', startGameFromConfig);
  }
  
  // ä¸ºé…ç½®é¡µé¢çš„è¾“å…¥æ¡†æ·»åŠ å›è½¦é”®æ”¯æŒ
  const configInputs = document.querySelectorAll('#configModal input, #configModal select');
  configInputs.forEach(input => {
    input.addEventListener('keypress', function(e) {
      if (e.key === 'Enter') {
        startGameFromConfig();
      }
    });
  });
});

let gameOverBalloonTimer = null;
let gameOverBalloonEndTime = 0;

// åªä¿ç•™xå’Œyéƒ½ä¸ºå¶æ•°ï¼Œxã€yä¸ºç¼–å·ï¼Œvalueå½’ä¸€åŒ–
function convertHeatmapToGridAndNormalize(data) {
  const filtered = data.filter(([x, y, value]) => y % 2 === 0 && x % 2 === 0);
  const maxValue = Math.max(...filtered.map(item => item[2]));
  return filtered.map(([x, y, value]) => {
    let norm = value / (maxValue || 1);
    norm = Math.pow(norm, 0.7); // å¦‚éœ€æ›´äº‘é›¾å¯ä¿ç•™ï¼Œå¦åˆ™ç›´æ¥ç”¨norm
    return [x, y, norm];
  });
}
 